{"id": "Rd4wP4LpQ2", "cdate": 1672531200000, "mdate": 1682327066517, "content": {"title": "The Packing Chromatic Number of the Infinite Square Grid is 15", "abstract": "A packing $k$-coloring is a natural variation on the standard notion of graph $k$-coloring, where vertices are assigned numbers from $\\{1, \\ldots, k\\}$, and any two vertices assigned a common color $c \\in \\{1, \\ldots, k\\}$ need to be at a distance greater than $c$ (as opposed to $1$, in standard graph colorings). Despite a sequence of incremental work, determining the packing chromatic number of the infinite square grid has remained an open problem since its introduction in 2002. We culminate the search by proving this number to be 15. We achieve this result by improving the best-known method for this problem by roughly two orders of magnitude. The most important technique to boost performance is a novel, surprisingly effective propositional encoding for packing colorings. Additionally, we developed an alternative symmetry-breaking method. Since both new techniques are more complex than existing techniques for this problem, a verified approach is required to trust them. We include both techniques in a proof of unsatisfiability, reducing the trusted core to the correctness of the direct encoding."}}
{"id": "zD65Zdh6ZhI", "cdate": 1652737819976, "mdate": null, "content": {"title": "On Computing Probabilistic Explanations for Decision Trees", "abstract": "  Formal XAI (explainable AI) is a growing area that focuses on computing explanations with mathematical guarantees for the decisions made by ML models. Inside formal XAI, one of the most studied cases is that of explaining the choices taken by decision trees, as they are traditionally deemed as one of the most interpretable classes of models. Recent work has focused on studying the computation of sufficient reasons, a kind of explanation in which given a decision tree $T$ and an instance $x$, one explains the decision $T(x)$ by providing a subset $y$ of the features of $x$ such that for any other instance $z$ compatible with $y$, it holds that  $T(z) = T(x)$, intuitively meaning that the features in $y$ are already enough to fully justify the classification of $x$ by $T$. \nIt has been argued, however, that sufficient reasons constitute a restrictive notion of explanation. For such a reason, the community has started to study their probabilistic counterpart, in which one requires that the probability of $T(z) = T(x)$ must be at least some value $\\delta \\in (0, 1]$, where $z$ is a random instance that is compatible with $y$. Our paper settles the computational complexity of $\\delta$-sufficient-reasons over decision trees, showing that both (1) finding $\\delta$-sufficient-reasons  that are minimal in size, and (2) finding $\\delta$-sufficient-reasons that are minimal inclusion-wise, do not admit polynomial-time algorithms (unless P = NP).\n   This is in stark contrast with the deterministic case ($\\delta = 1$) where inclusion-wise minimal sufficient-reasons are easy to compute. By doing this, we answer two open problems originally raised by Izza et al., and extend the hardness of explanations for Boolean circuits presented by W{\\\"a}ldchen et al. to the more restricted case of decision trees. On the positive side, we identify structural restrictions of decision trees that make the problem tractable, and show how SAT solvers might be able to tackle these problems in practical settings."}}
{"id": "HFkxZ_V0sBQ", "cdate": 1652737767238, "mdate": null, "content": {"title": "Augmenting Online Algorithms with $\\varepsilon$-Accurate Predictions", "abstract": "The growing body of work in learning-augmented online algorithms studies how online algorithms can be improved when given access to ML predictions about the future. Motivated by ML models that give a confidence parameter for their predictions, we study online algorithms with predictions that are $\\epsilon$-accurate: namely, each prediction is correct with probability (at least) $\\epsilon$, but can be arbitrarily inaccurate with the remaining probability. We show that even with predictions that are accurate with a small probability and arbitrarily inaccurate otherwise, we can dramatically outperform worst-case bounds for a range of classical online problems including caching, online set cover, and online facility location. Our main results are an $O(\\log(1/\\varepsilon))$-competitive algorithm for caching, and a simple $O(1/\\varepsilon)$-competitive algorithm for a large family of covering problems, including set cover and facility location, with $\\epsilon$-accurate predictions."}}
{"id": "u3ajZRuxjpj", "cdate": 1640995200000, "mdate": 1682327066450, "content": {"title": "Wordle Is NP-Hard", "abstract": "Wordle is a single-player word-guessing game where the goal is to discover a secret word w that has been chosen from a dictionary D. In order to discover w, the player can make at most \ud835\udcc1 guesses, which must also be words from D, all words in D having the same length k. After each guess, the player is notified of the positions in which their guess matches the secret word, as well as letters in the guess that appear in the secret word in a different position. We study the game of Wordle from a complexity perspective, proving NP-hardness of its natural formalization: to decide given a dictionary D and an integer \ud835\udcc1 if the player can guarantee to discover the secret word within \ud835\udcc1 guesses. Moreover, we prove that hardness holds even over instances where words have length k = 5, and that even in this case it is NP-hard to approximate the minimum number of guesses required to guarantee discovering the secret word. We also present results regarding its parameterized complexity and offer some related open problems."}}
{"id": "qaQbt9fAC2p", "cdate": 1640995200000, "mdate": 1681565118900, "content": {"title": "On Computing Probabilistic Explanations for Decision Trees", "abstract": ""}}
{"id": "g9mU6dqG6qd", "cdate": 1640995200000, "mdate": 1682327066519, "content": {"title": "Wordle is NP-hard", "abstract": "Wordle is a single-player word-guessing game where the goal is to discover a secret word $w$ that has been chosen from a dictionary $D$. In order to discover $w$, the player can make at most $\\ell$ guesses, which must also be words from $D$, all words in $D$ having the same length $k$. After each guess, the player is notified of the positions in which their guess matches the secret word, as well as letters in the guess that appear in the secret word in a different position. We study the game of Wordle from a complexity perspective, proving NP-hardness of its natural formalization: to decide given a dictionary $D$ and an integer $\\ell$ if the player can guarantee to discover the secret word within $\\ell$ guesses. Moreover, we prove that hardness holds even over instances where words have length $k = 5$, and that even in this case it is NP-hard to approximate the minimum number of guesses required to guarantee discovering the secret word. We also present results regarding its parameterized complexity and offer some related open problems."}}
{"id": "aNUOxRlP63C", "cdate": 1640995200000, "mdate": 1681565118888, "content": {"title": "On the expressiveness of Lara: A proposal for unifying linear and relational algebra", "abstract": ""}}
{"id": "RPtUgQ7mfuy", "cdate": 1640995200000, "mdate": 1682327066535, "content": {"title": "The Packing Chromatic Number of the Infinite Square Grid Is at Least 14", "abstract": "A packing k-coloring of a graph G = (V, E) is a mapping from V to {1, ..., k} such that any pair of vertices u, v that receive the same color c must be at distance greater than c in G. Arguably the most fundamental problem regarding packing colorings is to determine the packing chromatic number of the infinite square grid. A sequence of previous works has proved this number to be between 13 and 15. Our work improves the lower bound to 14. Moreover, we present a new encoding that is asymptotically more compact than the previously used ones."}}
{"id": "Jyxmk4wUoQV", "cdate": 1621630150235, "mdate": null, "content": {"title": "Foundations of Symbolic Languages for Model Interpretability", "abstract": "Several queries and scores have recently been proposed to explain individual predictions over ML models. Examples include queries based on \u201canchors\u201d, which are parts of an instance that are sufficient to justify its classification, and \u201cfeature-perturbation\u201d scores such as SHAP. Given the need for flexible, reliable, and easy-to-apply interpretability methods for ML models, we foresee the need for developing declarative languages to naturally specify different explainability queries. We do this in a principled way by rooting such a language in a logic called FOIL, which allows for expressing many simple but important explainability queries, and might serve as a core for more expressive interpretability languages. We study the computational complexity of FOIL queries over two classes of ML models often deemed to be easily interpretable: decision trees and more general decision diagrams. Since the number of possible inputs for an ML model is exponential in its dimension, tractability of the FOIL evaluation problem is delicate but can be achieved by either restricting the structure of the models, or the fragment of FOIL being evaluated.  We also present a prototype implementation of FOIL wrapped in a high-level declarative language and perform experiments showing that such a language can be used in practice."}}
{"id": "b2CLQRwDIp", "cdate": 1609459200000, "mdate": 1682327066511, "content": {"title": "The Computational Complexity of Evil Hangman", "abstract": "The game of Hangman is a classical asymmetric two player game in which one player, the setter, chooses a secret word from a language, that the other player, the guesser, tries to discover through single letter matching queries, answered by all occurrences of this letter if any. In the Evil Hangman variant, the setter can change the secret word during the game, as long as the new choice is consistent with the information already given to the guesser. We show that a greedy strategy for Evil Hangman can perform arbitrarily far from optimal, and most importantly, that playing optimally as an Evil Hangman setter is computationally difficult. The latter result holds even assuming perfect knowledge of the language, for several classes of languages, ranging from Finite to Turing Computable. The proofs are based on reductions to Dominating Set on 3-regular graphs and to the Membership problem, combinatorial problems already known to be computationally hard."}}

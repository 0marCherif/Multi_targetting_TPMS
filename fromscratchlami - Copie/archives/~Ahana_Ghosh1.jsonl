{"id": "0QtnzcMtKP", "cdate": 1640995200000, "mdate": 1681506701310, "content": {"title": "Adaptive Scaffolding in Block-Based Programming via Synthesizing New Tasks as Pop Quizzes", "abstract": ""}}
{"id": "f61lEu3yFMk", "cdate": 1577836800000, "mdate": null, "content": {"title": "Towards Deployment of Robust Cooperative AI Agents: An Algorithmic Framework for Learning Adaptive Policies", "abstract": "We study the problem of designing an AI agent that can robustly cooperate with agents of unknown type (i.e., previously unobserved behavior) in multi-agent scenarios. Our work is inspired by real-world applications in which an AI agent, e.g., a virtual assistant, has to cooperate with new types of agents/users after its deployment. We model this problem via parametric Markov Decision Processes where the parameters correspond to a user's type and characterize her behavior. In the test phase, the AI agent has to interact with a user of an unknown type. We develop an algorithmic framework for learning adaptive policies: our approach relies on observing the user's actions to make inferences about the user's type and adapting the policy to facilitate efficient cooperation. We show that without being adaptive, an AI agent can end up performing arbitrarily bad in the test phase. Using our framework, we propose two concrete algorithms for computing policies that automatically adapt to the user in the test phase. We demonstrate the effectiveness of our algorithms in a cooperative gathering game environment for two agents."}}
{"id": "LCvrXUOKgyR", "cdate": 1577836800000, "mdate": null, "content": {"title": "Zero-shot Learning of Hint Policy via Reinforcement Learning and Program Synthesis", "abstract": ""}}
{"id": "B_8wP0kOV8i", "cdate": 1577836800000, "mdate": null, "content": {"title": "Synthesizing Tasks for Block-based Programming", "abstract": "Block-based visual programming environments play a critical role in introducing computing concepts to K-12 students. One of the key pedagogical challenges in these environments is in designing new practice tasks for a student that match a desired level of difficulty and exercise specific programming concepts. In this paper, we formalize the problem of synthesizing visual programming tasks. In particular, given a reference visual task $\\rm T^{in}$ and its solution code $\\rm C^{in}$, we propose a novel methodology to automatically generate a set $\\{(\\rm T^{out}, \\rm C^{out})\\}$ of new tasks along with solution codes such that tasks $\\rm T^{in}$ and $\\rm T^{out}$ are conceptually similar but visually dissimilar. Our methodology is based on the realization that the mapping from the space of visual tasks to their solution codes is highly discontinuous; hence, directly mutating reference task $\\rm T^{in}$ to generate new tasks is futile. Our task synthesis algorithm operates by first mutating code $\\rm C^{in}$ to obtain a set of codes $\\{\\rm C^{out}\\}$. Then, the algorithm performs symbolic execution over a code $\\rm C^{out}$ to obtain a visual task $\\rm T^{out}$; this step uses the Monte Carlo Tree Search (MCTS) procedure to guide the search in the symbolic tree. We demonstrate the effectiveness of our algorithm through an extensive empirical evaluation and user study on reference tasks taken from the \\emph{Hour of Code: Classic Maze} challenge by \\emph{Code.org} and the \\emph{Intro to Programming with Karel} course by \\emph{CodeHS.com}."}}
{"id": "6xEwTQXz9Sx", "cdate": 1577836800000, "mdate": null, "content": {"title": "Synthesizing Tasks for Block-based Programming", "abstract": "Block-based visual programming environments play a critical role in introducing computing concepts to K-12 students. One of the key pedagogical challenges in these environments is in designing new practice tasks for a student that match a desired level of difficulty and exercise specific programming concepts. In this paper, we formalize the problem of synthesizing visual programming tasks. In particular, given a reference visual task $\\task^{in}$ and its solution code $\\code^{in}$, we propose a novel methodology to automatically generate a set $\\{(\\task^{out}, \\code^{out})\\}$ of new tasks along with solution codes such that tasks $\\task^{in}$ and $\\task^{out}$ are conceptually similar but visually dissimilar. Our methodology is based on the realization that the mapping from the space of visual tasks to their solution codes is highly discontinuous; hence, directly mutating reference task $\\task^{in}$ to generate new tasks is futile. Our task synthesis algorithm operates by first mutating code $\\code^{in}$ to obtain a set of codes $\\{\\code^{out}\\}$. Then, the algorithm performs symbolic execution over a code $\\code^{out}$ to obtain a visual task $\\task^{out}$; this step uses the Monte Carlo Tree Search (MCTS) procedure to guide the search in the symbolic tree. We demonstrate the effectiveness of our algorithm through an extensive empirical evaluation and user study on reference tasks taken from the Hour of Code: Classic Maze challenge by Code.org and the Intro to Programming with Karel course by CodeHS.com."}}
{"id": "tZOSppgJRz", "cdate": 1546300800000, "mdate": null, "content": {"title": "Learner-aware Teaching: Inverse Reinforcement Learning with Preferences and Constraints", "abstract": "Inverse reinforcement learning (IRL) enables an agent to learn complex behavior by observing demonstrations from a (near-)optimal policy. The typical assumption is that the learner's goal is to match the teacher\u2019s demonstrated behavior. In this paper, we consider the setting where the learner has its own preferences that it additionally takes into consideration. These preferences can for example capture behavioral biases, mismatched worldviews, or physical constraints. We study two teaching approaches: learner-agnostic teaching, where the teacher provides demonstrations from an optimal policy ignoring the learner's preferences, and learner-aware teaching, where the teacher accounts for the learner\u2019s preferences. We design learner-aware teaching algorithms and show that significant performance improvements can be achieved over learner-agnostic teaching."}}

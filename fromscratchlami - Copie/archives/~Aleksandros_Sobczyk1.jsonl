{"id": "9fxpigLiP9I", "cdate": 1669852800000, "mdate": 1683110727528, "content": {"title": "pylspack: Parallel Algorithms and Data Structures for Sketching, Column Subset Selection, Regression, and Leverage Scores", "abstract": "We present parallel algorithms and data structures for three fundamental operations in Numerical Linear Algebra: (i) Gaussian and CountSketch random projections and their combination, (ii) computation of the Gram matrix, and (iii) computation of the squared row norms of the product of two matrices, with a special focus on \u201ctall-and-skinny\u201d matrices, which arise in many applications. We provide a detailed analysis of the ubiquitous CountSketch transform and its combination with Gaussian random projections, accounting for memory requirements, computational complexity and workload balancing. We also demonstrate how these results can be applied to column subset selection, least squares regression and leverage scores computation. These tools have been implemented in pylspack, a publicly available Python package1 whose core is written in C++ and parallelized with OpenMP and that is compatible with standard matrix data structures of SciPy and NumPy. Extensive numerical experiments indicate that the proposed algorithms scale well and significantly outperform existing libraries for tall-and-skinny matrices."}}
{"id": "_N4k45mtnuq", "cdate": 1652737419366, "mdate": null, "content": {"title": "Approximate Euclidean lengths and distances beyond Johnson-Lindenstrauss", "abstract": "A classical result of Johnson and Lindenstrauss states that a set of $n$ high dimensional data points can be projected down to $O(\\log n/\\epsilon^2)$ dimensions such that the square of their pairwise distances is preserved up to a small distortion $\\epsilon\\in(0,1)$. It has been proved that the JL lemma is optimal for the general case, therefore, improvements can only be explored for special cases. This work aims to improve the $\\epsilon^{-2}$ dependency based on techniques inspired by the Hutch++ Algorithm, which reduces $\\epsilon^{-2}$ to $\\epsilon^{-1}$ for the related problem of implicit matrix trace estimation. We first present an algorithm to estimate the Euclidean lengths of the rows of a matrix. We prove for it element-wise probabilistic bounds that are at least as good as standard JL approximations in the worst-case, but are asymptotically better for matrices with decaying spectrum. Moreover, for any matrix, regardless of its spectrum, the algorithm achieves $\\epsilon$-accuracy for the total, Frobenius norm-wise relative error using only $O(\\epsilon^{-1})$ queries. This is a quadratic improvement over the norm-wise error of standard JL approximations. We also show how these results can be extended to estimate (i) the Euclidean distances between data points and (ii) the statistical leverage scores of tall-and-skinny data matrices, which are ubiquitous for many applications, with analogous theoretical improvements. Proof-of-concept numerical experiments are presented to validate the theoretical analysis."}}
{"id": "4Of1ZfQNr-", "cdate": 1640995200000, "mdate": 1683110727525, "content": {"title": "Approximate Euclidean lengths and distances beyond Johnson-Lindenstrauss", "abstract": "A classical result of Johnson and Lindenstrauss states that a set of $n$ high dimensional data points can be projected down to $O(\\log n/\\epsilon^2)$ dimensions such that the square of their pairwise distances is preserved up to a small distortion $\\epsilon\\in(0,1)$. It has been proved that the JL lemma is optimal for the general case, therefore, improvements can only be explored for special cases. This work aims to improve the $\\epsilon^{-2}$ dependency based on techniques inspired by the Hutch++ Algorithm, which reduces $\\epsilon^{-2}$ to $\\epsilon^{-1}$ for the related problem of implicit matrix trace estimation. We first present an algorithm to estimate the Euclidean lengths of the rows of a matrix. We prove for it element-wise probabilistic bounds that are at least as good as standard JL approximations in the worst-case, but are asymptotically better for matrices with decaying spectrum. Moreover, for any matrix, regardless of its spectrum, the algorithm achieves $\\epsilon$-accuracy for the total, Frobenius norm-wise relative error using only $O(\\epsilon^{-1})$ queries. This is a quadratic improvement over the norm-wise error of standard JL approximations. We also show how these results can be extended to estimate (i) the Euclidean distances between data points and (ii) the statistical leverage scores of tall-and-skinny data matrices, which are ubiquitous for many applications, with analogous theoretical improvements. Proof-of-concept numerical experiments are presented to validate the theoretical analysis."}}
{"id": "rsu_F-H7eyw", "cdate": 1609459200000, "mdate": 1683110727524, "content": {"title": "Estimating Leverage Scores via Rank Revealing Methods and Randomization", "abstract": ""}}
{"id": "KMDONmnwCf", "cdate": 1420070400000, "mdate": 1683110727524, "content": {"title": "A general tridiagonal solver for coprocessors: Adapting g-Spike for the Intel Xeon Phi", "abstract": "Manycores like the Intel Xeon Phi and graphics processing units like the NVIDIA Tesla series are prime examples of systems for accelerating applications that run on current CPU multicores. It is therefore of interest to build fast, reliable linear system solvers targeting these architectures. Moreover, it is of interest to conduct cross comparisons between algorithmic implementations in order to organize the types of optimizations and transformations that are necessary when porting in order to succeed in obtaining performance portability. In this work we aim to present a detailed study of the adaptation and implementation of g-Spike for the Xeon Phi. g-Spike was originally developed to solve general tridiagonal systems on GPUs, on which it returns high performance while also solving systems for which other state-of-the-art general tridiagonal GPU solvers do not succeed. The solver is based on the Spike framework, using QR factorization without pivoting implemented via Givens rotations. We show the necessary adaptations on the Xeon Phi because of the significant differences in the programming models and the underlying architectures as well as the relative performance differences for data access and processing operations."}}
{"id": "F1hCIjl4yS", "cdate": 1420070400000, "mdate": 1683110727526, "content": {"title": "A direct tridiagonal solver based on Givens rotations for GPU architectures", "abstract": ""}}

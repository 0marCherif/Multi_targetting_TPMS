{"id": "LRhBcMzVkt", "cdate": 1672531200000, "mdate": 1707084314031, "content": {"title": "Efficiently Computing Sparse Fourier Transforms of q-ary Functions", "abstract": "Fourier transformations of pseudo-Boolean functions are popular tools for analyzing functions of binary sequences. Real-world functions often have structures that manifest in a sparse Fourier transform, and previous works have shown that under the assumption of sparsity the transform can be computed efficiently. But what if we want to compute the Fourier transform of functions defined over a q-ary alphabet? These types of functions arise naturally in many areas including biology. A typical workaround is to encode the q-ary sequence in binary however, this approach is computationally inefficient and fundamentally incompatible with the existing sparse Fourier transform techniques. Herein, we develop a sparse Fourier transform algorithm specifically for q-ary functions of length n sequences, dubbed q-SFT, which provably computes an S-sparse transform with vanishing error as q <sup xmlns:mml=\"http://www.w3.org/1998/Math/MathML\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">n</sup> \u2192 \u221e in O(Sn) function evaluations and O(Sn <sup xmlns:mml=\"http://www.w3.org/1998/Math/MathML\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">2</sup> log q) computations, where S = q <sup xmlns:mml=\"http://www.w3.org/1998/Math/MathML\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">n\u03b4</sup> for some \u03b4 < 1. Under certain assumptions, we show that for fixed q, a robust version of q-SFT has a sample complexity of O(Sn <sup xmlns:mml=\"http://www.w3.org/1998/Math/MathML\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">2</sup> ) and a computational complexity of O(Sn <sup xmlns:mml=\"http://www.w3.org/1998/Math/MathML\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">3</sup> ) with the same asymptotic guarantees. We present numerical simulations on synthetic and real-world RNA data, demonstrating the scalability of q-SFT to massively high dimensional q-ary functions."}}
{"id": "9UT1yKGgDA", "cdate": 1577836800000, "mdate": 1707084314032, "content": {"title": "Minimum Feedback for Collision-Free Scheduling in Massive Random Access", "abstract": "This paper considers a massive random access scenario where a small random set of k active users out of a larger number of n total potential users seek to transmit data to a base station. Specifically, we examine an approach in which the base station first determines the set of active users based on an uplink pilot phase, then broadcasts a common feedback message to all the active users for the scheduling of their subsequent data transmissions. Our main question is: What is the minimum amount of common feedback needed to schedule k users in k slots while completely avoiding collisions? Instead of a naive scheme of using k log(n) feedback bits, this paper presents upper and lower bounds to show that the minimum number of required common feedback bits scales linearly in k, plus an additive term that scales only as \u0398(log log(n)). The achievability proof is based on a random coding argument. We further connect the problem of constructing a minimal length feedback code to that of finding a minimal set of complete k-partite subgraphs that form an edge covering of a k-uniform complete hypergraph with n vertices. Moreover, the problem is also equivalent to that of finding a minimal perfect hashing family, thus allowing leveraging the explicit perfect hashing code constructions for achieving collision-free massive random access."}}
